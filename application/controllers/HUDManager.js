/**
 * HUDManager is user to manage all HUD design operations
 * Full CRUD cycle for every supported HUD Item
 * @type {*}
 */
visualHUD.Controllers.HUDManager = Backbone.Controller.extend({
    views: [
        'HUDItem',
        'HUDItemForm'
    ],

    models: [
        'HUDItem',
        'ClientSettings'
    ],

    collections: [
        'HUDItemTemplates',
        'HUDItemIconEnums',
        'HUDItems',
        'CustomHUDPresets'
    ],

    AUTOSAVE_TIMEOUT: 300000,

    initialize: function(options) {
        this.addListeners({
            'Viewport': {
                'import.image': this.importImage,
                'import.text': this.importHUDPresets
            },        
            'viewport.TopBar': {
                'align.action': this.alignItems,
                'toolbar.hud:action': this.groupActions
            },        
            'viewport.StageControls': {
                'item.drop': this.dropNewHUDItem
            },
            'viewport.Canvas': {
                'drop.move': this.onItemMove
            },
            'windows.ImportHUD': {
                'load': this.loadHUD,
                'download.preset': this.downloadPreset,
                'import.text': this.importHUDPresets
            },
            'windows.Download': {
                'download': this.onDownload
            },
            'windows.ImportImage': {
                'import': this.importImage
            },
            'Form': {
                'align.action': this.alignItems,
                'arrange.action': this.arrangeItems
            },
            'HUDItem': {
                'click': this.onHUDItemClick,
                'destroy': this.onHUDItemDestroy
            },
            // Events generated by KeyboardManager Controller
            'keyboard': {
                'select.all': this.selectAllHUDItems,
                'delete': this.deleteSelectedItems,
                'move': this.moveSelectedItems,
                'group': this.groupSelectedItems,
                'clone': this.cloneSelectedItems,
                'arrange': this.arrangeItems
            }
        });
    },

    onLaunch: function() {
        var HUDItemsCollection = this.getCollection('HUDItems');
        var clientSettingsModel = this.getModel('ClientSettings');

        clientSettingsModel.on('change', this.updateHUDItemStatus, this);

        HUDItemsCollection.on('add', this.addNewHUDItem, this);
        // HUDItemsCollection.on('change', this.syncPresets, this);
        HUDItemsCollection.on('load', this.loadDraft, this);

        // Load saved HUD Items
        $(window).load(visualHUD.Function.bind(HUDItemsCollection.load, HUDItemsCollection, []));
    },

    /**
     * Event handler triggered by visualHUD.Collections.HUDItems
     * Restore previously saved draft
     */
    loadDraft: function() {
        console.log('load draft triggered');

        if(this.getCollection('HUDItems').length == 0) {
            return this.showGetStartedMessage();
        }

        var canvasView = this.getApplicationView('viewport.Canvas'),
            trash = [];

        canvasView.beginUpdate();

        this.selectAllHUDItems();
        this.deleteSelectedItems();

        this.getCollection('HUDItems').each(function(record) {
            var statusText = this.getModel('ClientSettings').getStatusByName(record.get('name'));
            (statusText) && record.set('text', statusText, {silent: true});

            // using try catch in order to skip damaged/incorrect hud items
            try {
                this.createNewHUDItem(record);
            }
            catch(e) {
                trash.push(record);
                console.warn('Invalid HUD Data!', record.toJSON());
            }
        }, this);
        // remove damaged items from collection
        // and show error message        
        if(trash.length) {
            this.application.growl.alert({
                status: 'warning',
                title: 'Some Items Were Not Imported',
                message: _.template(visualHUD.messages.HUD_ELEMENTS_PARSE_ERROR, {count: trash.length})
            });
            this.getCollection('HUDItems').remove(trash);
        }
        canvasView.completeUpdate();
    },

    showGetStartedMessage: function() {
        var $message = this.application.growl.alert({
            status: 'info',
            title: 'Get Started',
            delay: 20000,
            message: ([
                '<p>Visual HUD is ready to rock, but there are no HUD items yet. Would you like to import something?</p>',
                '<a href="#" class="import">Import HUD</a>'
            ]).join('')
        });

        $message.find('a.import').click(visualHUD.Function.bind(function() {
            var view = this.getApplicationView('windows.ImportHUD');

            if(this.getCollection('CustomHUDPresets').length > 0) {
                view.importCustom();
            }
            else {
                view.importPredefined();
            }

            this.application.growl.hide($message);
            return false;
        }, this));
    },

    /**
     * Event handler triggered by StageControls View when new HUD Item has been dropped to the canvas
     * @param record
     * @param position
     */
    dropNewHUDItem: function(record, position) {
        var HUDItemModelClass = this.getModelConstructor('HUDItem');
        var HUDItemModel = new HUDItemModelClass();
        var statusText = this.getModel('ClientSettings').getStatusByName(record.get('id'));

        HUDItemModel.setDefaultValues({
            name: record.get('id'),
            itemType: record.get('itemType')
        }).set({
            cssClass: record.get('cssClass'),
            label: record.get('label'),
            coordinates: position
        });

        HUDItemModel.wasDropped = true;

        if(statusText) {
            HUDItemModel.set('text', statusText);
        }

        this.getCollection('HUDItems').add(HUDItemModel);
    },

    /**
     * Create new visualHUD.Views.HUDItem instance based on visualHUD.Models.HUDItem data
     * @param record
     * @return {Object} HUDItem visualHUD.Views.HUDItem instance
     */
    createNewHUDItem: function(record) {
        var HUDItemTemplates = this.getCollection('HUDItemTemplates');
        var canvasView = this.getApplicationView('viewport.Canvas');
        var viewportView = this.getApplicationView('Viewport');
        var stageControlsView = viewportView.getStageControlsView();

        var HUDItemViewClass = this.getViewConstructor('HUDItem');
        var formViewClass = this.getViewConstructor('HUDItemForm');
        var HUDItemIconEnums = this.getCollection('HUDItemIconEnums')

        var formView = new formViewClass({
            alias: 'Form',
            model: record,
            renderTo: viewportView.$sidebarArea,
            collections: {
                'HUDItemIconEnums': HUDItemIconEnums
            }
        });

        var HUDItem = new HUDItemViewClass({
            alias: 'HUDItem',
            HUDItemIconEnums: HUDItemIconEnums,
            renderTo: canvasView.$canvas,
            model: record,
            wasDropped: record.wasDropped,
            formView: formView,
            htmlTplRecord: HUDItemTemplates.get(record.get('name'))
        });

        stageControlsView.updateControlsStatus('create', record.get('name'));

        delete record.wasDropped;

        return HUDItem;
    },

    /**
     * Event handler triggered by visualHUD.Collections.HUDItems when new record has been added to the collection
     * @param record
     */
    addNewHUDItem: function(record) {
        var canvasView = this.getApplicationView('viewport.Canvas');
        var HUDItem = this.createNewHUDItem(record);
        canvasView.select(HUDItem, false);
    },

    /**
     * Event handler Triggered by visualHUD.Libs.canvasDragInterface
     * @param HUDElementView
     */
    onItemMove: function(HUDElementView) {
        var canvasView = this.getApplicationView('viewport.Canvas');

        _.each(canvasView.getSelection(), function(view) {
            view.refreshCoordinates();
        });

        canvasView.disableSelection();
    },

    /**
     * Event handler triggered by visualHUD.Views.HUDItem when item is clicked
     * Used to blur focused form element and select clicked item
     * @param HUDItem
     * @param event
     */
    onHUDItemClick: function(HUDItem, event) {
        var canvasView = this.getApplicationView('viewport.Canvas');
        this.application.getController('FocusManager').blur();
        canvasView.select(HUDItem, event.shiftKey || event.ctrlKey);
        canvasView.enableSelection();
    },

    /**
     * Triggered by visualHUD.Views.HUDItem when item is destroyed
     * Used to update StageControls state (for example, enable chat icon)
     * @param record
     */
    onHUDItemDestroy: function(record) {
        var viewportView = this.getApplicationView('Viewport'),
            stageControlsView = viewportView.getStageControlsView();

        stageControlsView.updateControlsStatus('destroy', record.get('name'));
    },

    /**
     * Event handler Triggered by visualHUD.Models.ClientSettings
     * Used to update status of the particular HUD Item
     * @param model
     * @param options
     */
    updateHUDItemStatus: function(model, event) {
        var changes = event.changes;
        var HUDItemsCollection = this.getCollection('HUDItems');

        _.each(changes, function(set, field) {
            var value = model.get(field),
                namePattern,
				fieldToUpdate = 'text';

            switch(field) {
                case 'statusHealth': {
                    namePattern = /healthIndicator|healthBar/;
                    break;
                }
                case 'statusArmor': {
                    namePattern = /armorIndicator|armorBar/;
                    break;
                }
                case 'statusAmmo': {
                    namePattern = /ammoIndicator/;
                    break;
                }
                case 'statusAccuracy': {
                    namePattern = /accuracyIndicator/;
                    break;
                }
                case 'statusSkill': {
                    namePattern = /skillIndicator/;
                    break;
                }
                case 'ownerDrawFlag': {
					return HUDItemsCollection.filterItemsByOwnerDraw(value);
                }
            }

            HUDItemsCollection.each(function(record){
                var name = record.get('name');

                if(namePattern && namePattern.test(name)) {
                    record.set(fieldToUpdate, value);
                }
            });
        }, this);
    },

    /**
     * Align items action delegated to the visualHUD.Libs.layersManager
     * Triggered by different buttons
     * @param value
     */
    alignItems: function(value){
        var canvasView = this.getApplicationView('viewport.Canvas');
        visualHUD.Libs.layersManager.alignEdges(canvasView, value);

        _.each(canvasView.getSelection(), function(view) {
            view.refreshCoordinates();
        });
    },

    /**
     * Arrange items action delegated to the visualHUD.Libs.layersManager
     * Triggered by different buttons
     * @param value
     */
    arrangeItems: function(value){
        var canvasView = this.getApplicationView('viewport.Canvas');
        visualHUD.Libs.layersManager.arrangeLayers(canvasView, value);
        canvasView.updateIndexes();
        this.getCollection('HUDItems').sort();
    },
    /**
     * Triggered by TopBar view when HUD action buttons are clicked
     * @param {String} action The name of the action being triggered
     */
    groupActions: function(action){
        switch(action) {
            case 'deleteSelected': {
                this.deleteSelectedItems();
                break;
            }
            case 'groupSelected': {
                this.groupSelectedItems();
                break;
            }
            case 'cloneSelected': {
                this.cloneSelectedItems();
                break;
            }
            case 'undoUpdate': {
                this.application.getController('HistoryManager').undo();
                break;
            }
        }
    },
    /**
     * Function to select all HUD items
     * @param event
     */
    selectAllHUDItems: function(event) {
        var canvas = this.getApplicationView('viewport.Canvas');
        canvas.selectAll();
    },

    /**
     * Event triggered by KeyboardManager controller when pressing DEL button
     */
    deleteSelectedItems: function() {
        var canvas = this.getApplicationView('viewport.Canvas'),
            selection = canvas.getSelection();

        // reset HUDName if all HUD items are deleted
        if(this.getCollection('HUDItems').length == selection.length) {
            this.getModel('ClientSettings').set('HUDName', null);
        }

        _.each(selection, function(view) {
            view.model.destroy();
        });

        canvas.deselect();
    },

    /**
     * Event triggered by KeyboardManager controller when pressing arrow buttons
     * @param direction
     * @param offset
     */
    moveSelectedItems: function(direction, offset) {
        var canvas = this.getApplicationView('viewport.Canvas'),
            selection = canvas.getSelection();

        _.each(selection, function(view) {
            view.move(direction, offset);
        });
    },

    /**
     * Function to clone group/ungroup selected items
     * @param event
     */
    groupSelectedItems: function() {
        var canvas = this.getApplicationView('viewport.Canvas'),
            selection = canvas.getSelection(),
            masterElement = selection[0];
            isUngroup = false,
            groupGuid = null;

        _.each(selection, function(view) {
            if(view.getGroup()) {
                isUngroup = true;
            }
            else {
                groupGuid = groupGuid || visualHUD.Libs.utility.getGuid();
            }
            view.setGroup(groupGuid);
        });

        if(isUngroup == true) {
            canvas.deselect();
            canvas.select(masterElement);
        }
    },

    /**
     * Function to clone selected items
     * @param event
     */
    cloneSelectedItems: function(event) {
        var canvasView = this.getApplicationView('viewport.Canvas'),
            selection = Array.prototype.slice.call(canvasView.getSelection()),
            HUDItemModelClass = this.getModelConstructor('HUDItem');

        canvasView.deselect();

        _.each(selection, function(view) {
            var cloneData = view.model.toJSON();

            _.extend(cloneData, {
                group: null,
                coordinates: {
                    top: cloneData.coordinates.top + 10,
                    left: cloneData.coordinates.left + 10
                }
            });

            var newRecord = new HUDItemModelClass(cloneData),
                newItem = this.createNewHUDItem(newRecord);

            this.getCollection('HUDItems').add(newRecord, {silent: true});

            canvasView.select(newItem, true);
        }, this);
    },

    /**
     * Triggered by visualHUD.Views.LoadWindow when new HUD preset is being loaded
     * @param data
     */
    loadHUD: function(data, name, suppressLoad) {
        var name = data.name || name;

        if(_.isArray(data)) {
            data = {
                name: name,
                items: data
            }
        }

        if(name) {
            this.addCustomHUDPreset(data);
        }
        else {
            this.getModel('ClientSettings').set('HUDName', null);
        }

        var action = this.getCollection('HUDItems').length && suppressLoad !== true ?
                        window.confirm(visualHUD.messages.CONFIRM_HUD_OVERWRITE) : true;

        if(suppressLoad !== true && action) {
            this.getCollection('HUDItems').load(data.items);
        }

    },

    onDownload: function(view, data) {
        var values = view.serializeForm();

        if(values['save_preset']) {
            this.addCustomHUDPreset({
                name: data.name,
                items: view.collection.toJSON()
            });
        }
        else {
            this.getModel('ClientSettings').set('HUDName', null);
        }
    },

    downloadPreset: function(data) {
        var dlWindow = this.getApplicationView('windows.Download');

        dlWindow.setHUDData(data);
        dlWindow.getForm().submit();
    },

    syncPresets: function() {
        var HUDName = this.getModel('ClientSettings').get('HUDName');

        if(HUDName) {
            this.addCustomHUDPreset({
                name: HUDName,
                items: this.getCollection('HUDItems').toJSON()
            });
        }
    },

    addCustomHUDPreset: function(data) {
        var items = data.items,
            name = data.name,
            builtIn = data.isBuiltIn;

        if(builtIn === true) {
            return;
        }

        var presetRecord = this.getCollection('CustomHUDPresets').find(function(record) {
                return record.get('name') == name;
            });
            
        if(presetRecord) {
            presetRecord.set('items', items);
        }
        else {
            this.getCollection('CustomHUDPresets').add(data);
        }
        
        this.getModel('ClientSettings').set('HUDName', name);
    },

    /**
     * Triggered by visualHUD.Views.ImportImageWindow when new image is being uploaded
     * @param src
     */
    importImage: function(src) {
        var clientSettingsModel = this.getModel('ClientSettings');
        clientSettingsModel.set({
            'customBackground': src,
            'canvasShot': 3
        });
        this.getApplicationView('viewport.CanvasToolbar').setClientSettings({
            'canvasShot': 3
        });
    },
    
    importHUDPresets: function(presets) {
        var data = [],
            success = true,
            loadWindow = this.getApplicationView('windows.ImportHUD'),
            openLoadWindow = loadWindow ? loadWindow.opened == false : true,
            length = this.getCollection('HUDItems').length;

        _.each(presets, function(preset, idx) {
            try {
                // set suppress boolean to true only for the fist item in the collection
                var suppress = idx == 0 ? length > 0 : true
                this.loadHUD(JSON.parse(preset.json), preset.name || null,  suppress);
            }
            catch(e) {
                success = false;
                console.error('Failed to import HUD', preset.json);
            }
        }, this);

        if(success) {
            var message = '<%= count %> HUD<%= count==1 ? \' has\' : \'s have\' %> been successfuly imported! ';

            if(openLoadWindow == true) {
                message = [
                    '<p>', message, 'Would you like to review the new items?', '</p>',
                    '<a href="#" class="import">Open import manager</a>'
                ];
            }
            else {
                message = [message];
            }

            var growl = this.application.growl,
                viewportController = this.application.getController('Viewport');

            var $alert = growl.alert({
                title: 'Hooray! ',
                status: 'success',
                message: _.template(message.join(''), {count: presets.length})
            });

            $alert.find('a.import').click(visualHUD.Function.bind(function() {
                viewportController.loadPreset();
                growl.hide($alert);
                return false;
            }, this));
        }

    }

});

